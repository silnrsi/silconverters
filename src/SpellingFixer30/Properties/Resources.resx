<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BulkGridHelp" xml:space="preserve">
    <value>This grid displays sets of words which are potentially misspelled. Your job (with your knowledge of the language) is to indicate 
whether one word in a row is a misspelled version of the other or whether both words are correct. 

Words which are marked as being correct will be added to the dictionary of known good words and words which are incorrect will be 
added to a database of bad-to-good pairs which can be used to fix the occurrences of the misspelled word.

If a word is only ambiguous with one other word, then the two words will form a single row. The word which has the highest occurrence 
count (or which is already in the dictionary of known good words) will be on the right-side and the similarly spelled word will be on 
the left-hand side.

As you process a row, type one of the following 3 keys:

 o Space: to indicate that both the right and left side are correctly spelled words. Both words will be added to the dictionary 
    of known good words (if they aren't already in it). Alternately you can click on the center column to accomplish the same thing.
 o Right-arrow: to indicate that the right-side word is correct and the left side is misspelled. This will cause the right-side 
    word to be put in the dictionary of known good words and a bad-to-good spell fixing rule to be added to the database. 
    Alternately, you can click on one of the right-hand side columns to accomplish the same thing.
 o Left-arrow: to indicate that the left-side word is correct and the right side is misspelled. This will cause the left-side word 
    to be put in the dictionary of known good words and an appropriate bad-to-good spell fixing rule to be added to the database. 
    Alternately, you can click on one of the left-hand side columns to accomplish the same thing.

If there are 3 or more words in a "bundle" which are similarly spelled, then they will be shown in multiple rows of the table. The 
word with the highest count (or that was in the dictionary of known good words) will be on the right-hand side of all of the rows 
in the bundle. If the word on the right-hand side is the correct spelling, then you can just process these rows as above. 

However, sometimes it happens that the lower occurrence word (i.e. on the left-hand side) is, in fact, the correct spelling. In this 
case, you can click (with the *right* mouse button) on the word in the left-hand side that you want to become the new right-hand side 
value and the grid will rearrange the words accordingly.

Also, it is sometimes the case that neither word is correct and both are unrelated to each other. In this case, you can right-click 
on the center column and the one row will become two rows with the two words from the original row becoming the left-hand side 
value of the two new rows. In this situation, you can click on the empty cell on the right-hand side to edit the bad-to-good spelling 
pair. You can click again on the same cell to undo the "split".

If you rest your cursor over either of the vernacular word cells, then a tooltip will appear showing you the context in which the 
word was found (this feature may not be available in all client applications).

If you have Toolbox running and if you click on a vernacular word while holding down the 'Ctrl' key, then Toolbox will be activated
and it will jump to the word that you clicked on.

Finally, the grid allows you to drag the columns and re-order them if you prefer a different order.
    </value>
  </data>
  <data name="checkBoxCompareDoubleCharsHelp" xml:space="preserve">
    <value>Check the "Compare double characters" box if you want words with two consecutive identical letters to be
compared with words that lack the two consecutive identical letters (e.g. "badda" will be considered a 
potential mispelling of "bada").
    </value>
  </data>
  <data name="checkBoxIgnoreCaseHelp" xml:space="preserve">
    <value>Check the "Ignore case" box if you want words with upper case letters to be compared with words that lack
upper case letters (e.g. "Philip" will be considered a potential misspelling of "philip"). This applies
to the Latin transliterated form of the words; not the vernacular forms.
    </value>
  </data>
  <data name="comboBoxVernScriptTypeHelp" xml:space="preserve">
    <value>Each vernacular writing system (e.g. Devanagari, Greek, Hebrew, etc.) can have different characteristics 
which are the source of frequent spelling mistakes. 

For example, Hindi has two different characters used for vowel nasalization (i.e. devanagari_sign_anusvara
and devanagari_sign_candrabindu). The rules for when to use one vs the other are ambiguous and consequently 
are the source of frequent spelling variation.

In fact, the Consistent Spelling Fixer application will typically work with any writing system by virtue
of the fact that vernacular forms are transliterated into "Latin" prior to being compared using the
ICU transliterator "Any to Latin". With this mechanism, the application doesn't need to know anything in 
particular about the different potential writing systems.

However, to make this program maximally useful, we provide a way to customize the transliterator used as 
well as the kind of characteristics which result in misspelled words for any particular writing systems.
This is done thru an XML file which can be copied and edited for different vernacular writing system.

One or more of these customization files were installed on your machine (by default in the
C:\ProgramData\SIL\ConsistentSpellingFixer\ScriptSystems folder). 
You can look at these files in any particular XML editor and copy and modify them for specific
differences that the default system doesn't allow. It is anticipated that your computer support personal
might develop one for each writing system in your group, which can then be distributed to the different
members to use rather than each user having to develop their own.

So the selection here is to indicate which "Vernacular Script System" file you'd like to associate with
this particular project.
    </value>
  </data>
  <data name="DistinctionRuleCheckBoxHelp" xml:space="preserve">
    <value>This box corresponds with a definition of a single ambiguity rule. It is defined in the Vernacular 
Script System file chosen on the previous tab and represents one potential source of spelling 
variation to be checked for. If you want to edit the rules, you can right-click on this item.
    </value>
  </data>
  <data name="DistinctionTreeHelp" xml:space="preserve">
    <value>This window is for entering simplification rules. This application works by comparing words that differ between 
the 'From' and 'Into' values in the tree below.
    
When a 'From' value occurs in a word, it will be 'simplified' into the 'Into' value so that it becomes ambiguous 
with the 'Into' value, which causes the program to consider them as inconsistent and potentially misspelled.

You want to create a simplification rule for any characters/strings which are frequently mixed up so that the 
program can find the inconsistencies.

In this tree, the leaf (right-most) nodes represent the character/string value(s) which will be turned into the
character/string value in its parent (left-most) node when simplifying strings in order to compare with each other.

Tip: a tree structure is used to allow you to simplify several different strings into the same 'Into' form.

You can:
 o Click on a 'From' node to edit its value in the boxes below.
 o Right-click on a tree node to add a new 'From' item to the corresponding 'Into' node.
 o Click on a '[Add new 'Into' value]' item to add a new 'Into' (and 'From') item to the tree
 
Boxes which are not checked will be excluded when you save and exit this window.
    </value>
  </data>
  <assembly alias="System.Windows.Forms" name="System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" />
  <data name="FillLeft" type="System.Resources.ResXFileRef, System.Windows.Forms">
    <value>..\Resources\FillLeft.bmp;System.Drawing.Bitmap, System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a</value>
  </data>
  <data name="textBoxBadWordHelp" xml:space="preserve">
    <value>
The "Bad Spelling" box shows a misspelled word in one of your documents. By creating a "bad to good" replacment rule, 
you are saying in effect, "Every time this Bad Spelling form occurs, it should be changed to the following Replacement 
form."

This box supports "Alt+X" behavior: If you enter the 4 hex digits of a Unicode code point, and type Alt+X, it will 
convert those four digits into the corresponding Unicode character (e.g. "0915" followed by Alt+X will result in the
Devanagari Unicode character /क/).
    </value>
  </data>
  <data name="textBoxReplacementHelp" xml:space="preserve">
    <value>
The "Replacement" box shows the correct spelling for the misspelled word in the "Bad Spelling" box. By creating a "bad 
to good" replacment rule, you are saying in effect, "Every time the Bad Spelling form occurs, it should be changed to 
this Replacement form."

This box supports "Alt+X" behavior: If you enter the 4 hex digits of a Unicode code point, and type Alt+X, it will 
convert those four digits into the corresponding Unicode character (e.g. "0915" followed by Alt+X will result in the
Devanagari Unicode character /क/).
    </value>
  </data>
  <data name="ViewBadGoodPairsBad2GoodHelp" xml:space="preserve">
    <value>
Select the word you want to change and press the F2 key to edit. 
When you are finished, press the Enter key to save the value.

You can also right click on a row to edit the words with the 
'Fix Spelling' window.

To delete a row, click on its row header, and press the Delete key.

To add a row, select the last (empty) row and follow the instructions 
above for editing.
    </value>
  </data>
  <data name="ViewBadGoodPairsDictionaryHelp" xml:space="preserve">
    <value>
Select the word you want to change and press the F2 key to edit. 
When you are finished, press the Enter key to save the value.

To delete a word, click on it, and press the Delete key.

To add a row, click on the last (empty) cell and press F2 to edit 
the new word.
    </value>
  </data>
</root>